/*
Implement a class Vector that represents a 2D mathematical vector and supports:
******************************************************************************

Basic initialization with two integers: x and y

A valueOf() method that returns a unique integer hash for the (x, y) vector.

A static method fromHash(hash) that takes a hash (generated by valueOf) and returns a new Vector(x, y) instance.

Arithmetic operations (optional but encouraged): addition, subtraction, scalar multiplication, division.

A method calculate(ops: Array) that processes a list of operations like:
[1, x, y] -> add Vector(x, y)
[2, x, y] -> subtract Vector(x, y)
[3, constant] -> multiply
[4, constant] -> divide

Sample Input/Output
*******************

const v = new Vector(5, 10);
const result = v.calculate([
  [1, 3, 2],     // Add (3, 2) → (8, 12)
  [2, 1, 1],     // Subtract (1, 1) → (7, 11)
  [3, 2],        // Multiply by 2 → (14, 22)
  [4, 2],        // Divide by 2 → (7, 11)
]);
console.log("Final:", result.toString());

*/

class Vector {
  static #MAX = 1000000; // 10^6
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  static valueOf(vector) {
    if (!vector instanceof Vector)
      throw new TypeError("Argument must be an instance of Vector");
    const { x, y } = vector;
    return x * this.#MAX + y;
  }

  static fromHash(hash) {
    if (!typeof hash == "number")
      throw new TypeError("Argument must be a number");
    const x = Math.floor(hash / this.#MAX);
    const y = Math.floor(hash % this.#MAX);
    return new Vector(x, y);
  }

  toString() {
    return `Vector(${this.x}, ${this.y})`;
  }

  #add(vector1, vector2) {
    if (!vector1 instanceof Vector || !vector2 instanceof Vector)
      throw new TypeError("Arguments must be instances of Vector");
    return new Vector(vector1.x + vector2.x, vector1.y + vector2.y);
  }

  #subtract(vector1, vector2) {
    if (!vector1 instanceof Vector || !vector2 instanceof Vector)
      throw new TypeError("Arguments must be instances of Vector");
    return new Vector(vector1.x - vector2.x, vector1.y - vector2.y);
  }

  #multiply(vector, constant) {
    if (!vector instanceof Vector)
      throw new TypeError("Arguments must be instances of Vector");
    return new Vector(vector.x * constant, vector.y * constant);
  }

  #divide(vector, constant) {
    if (!vector instanceof Vector)
      throw new TypeError("Arguments must be instances of Vector");
    return new Vector(vector.x / constant, vector.y / constant);
  }

  #calculateEach(untrustedData = []) {
    if (!untrustedData || untrustedData.length === 0)
      throw Error("Data is empty");

    if (untrustedData.length < 2 || untrustedData.length > 3)
      throw Error("Data length should be within the range of 2 to 3");

    const [type, ...vectorData] = untrustedData;

    let calculatedVector = this;

    switch (type) {
      case 1:
        calculatedVector = this.#add(
          calculatedVector,
          new Vector(vectorData[0], vectorData[1])
        );
        break;
      case 2:
        calculatedVector = this.#subtract(
          calculatedVector,
          new Vector(vectorData[0], vectorData[1])
        );
        break;
      case 3:
        calculatedVector = this.#multiply(calculatedVector, vectorData[0]);
        break;
      case 4:
        calculatedVector = this.#divide(calculatedVector, vectorData[0]);
        break;
      default:
        throw new Error("Unknown operation type");
    }
    return calculatedVector;
  }

  calculate(data = []) {
    let result = this;
    data.forEach((op) => {
      result = result.#calculateEach(op);
    });
    return result;
  }
}


// Test
const v = new Vector(1, 2);

const hash = Vector.valueOf(v); // Hash
console.log("Hash:", hash);

const restored = Vector.fromHash(hash); // Reverse hash
console.log(restored.toString()); 

// Calculate
const result = v.calculate([
  [1, 2, 3],    // add (2, 3)
  [2, 1, 2],    // subtract (1, 2)
  [3, 4],       // multiply by 4
  [4, 2]        // divide by 2
]);

console.log(result.toString()); 
